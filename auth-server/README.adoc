:star: {asterisk}
:all: {asterisk}{asterisk}

[[_social_login_authserver]]
= Hosting an Authorization Server

In this section. we modify the <<_social_login_github,github>> application we built by
making the application into a fully-fledged OAuth2 Authorization Server, still using
Facebook and Github for authentication but able to create its own access tokens. These
tokens could then be used to secure back-end resources or to do SSO with other
applications that we happen to need to secure the same way.

== Tidying up the Authentication Configuration

Before we start with the Authorization Server features, we are going
to tidy up the configuration code for the two external
providers. There is some code that is duplicated in the `ssoFilter()`
method, so we pull that out into a shared method, as follows:

.SocialApplication.java
====
[source,java]
----
private Filter ssoFilter() {
  CompositeFilter filter = new CompositeFilter();
  List<Filter> filters = new ArrayList<>();
  filters.add(ssoFilter(facebook(), "/login/facebook"));
  filters.add(ssoFilter(github(), "/login/github"));
  filter.setFilters(filters);
  return filter;
}
----
====

The new convenience method has all the duplicated code from the old
method, as the following listing shows:

.SocialApplication.java
====
[source,java]
----
private Filter ssoFilter(ClientResources client, String path) {
  OAuth2ClientAuthenticationProcessingFilter filter = new OAuth2ClientAuthenticationProcessingFilter(path);
  OAuth2RestTemplate template = new OAuth2RestTemplate(client.getClient(), oauth2ClientContext);
  filter.setRestTemplate(template);
  UserInfoTokenServices tokenServices = new UserInfoTokenServices(
      client.getResource().getUserInfoUri(), client.getClient().getClientId());
  tokenServices.setRestTemplate(template);
  filter.setTokenServices(tokenServices);
  return filter;
}
----
====

It uses a new wrapper object `ClientResources` that consolidates
the `OAuth2ProtectedResourceDetails` and the
`ResourceServerProperties` that were declared as separate `@Beans` in the last version of the application, as follows:

.SocialApplication.java
====
[source,java]
----
class ClientResources {

  @NestedConfigurationProperty
  private AuthorizationCodeResourceDetails client = new AuthorizationCodeResourceDetails();

  @NestedConfigurationProperty
  private ResourceServerProperties resource = new ResourceServerProperties();

  public AuthorizationCodeResourceDetails getClient() {
    return client;
  }

  public ResourceServerProperties getResource() {
    return resource;
  }
}
----
====

NOTE: The wrapper uses `@NestedConfigurationProperty` to instruct the annotation
processor to crawl that type for metadata as well, since it does not represent
a single value but a complete nested type.

With this wrapper in place, we can use the same YAML configuration as
before but with a single method for each provider, as follows:

.SocialApplication.java
====
[source,java]
----
@Bean
@ConfigurationProperties("github")
public ClientResources github() {
  return new ClientResources();
}

@Bean
@ConfigurationProperties("facebook")
public ClientResources facebook() {
  return new ClientResources();
}
----
====

== Enabling the Authorization Server

If we want to turn our application into an OAuth2 Authorization
Server, there is not a work to do, at least to get
started with some basic features (one client and the ability to create
access tokens). An authorization server is nothing more than a bunch
of endpoints, and they are implemented in Spring OAuth2 as Spring MVC
handlers. We already have a secure application, so it is really only a
matter of adding the `@EnableAuthorizationServer` annotation, as follows:

.SocialApplication.java
====
[source,java]
----
@SpringBootApplication
@RestController
@EnableOAuth2Client
@EnableAuthorizationServer
public class SocialApplication extends WebSecurityConfigurerAdapter {

   ...

}
----
====

With that new annotation in place, Spring Boot installs all the
necessary endpoints and sets up the security for them, provided we
supply a few details about the OAuth2 client we want to support, as follows:

.application.yml
====
[source,yaml]
----
security:
  oauth2:
    client:
      client-id: acme
      client-secret: acmesecret
      scope: read,write
      auto-approve-scopes: '.*'
----
====

This client is the equivalent of the `facebook.client{star}` and
`github.client{star}` that we need for the external
authentication. With the external providers, we had to register and get
a client ID and a secret to use in our app. In this case, we
provide our own equivalent of the same feature, so we need (at least
one) client for it to work.

NOTE: We have set the `auto-approve-scopes` to a regex that matches all
scopes. This is not necessarily where we would leave this application in a
real system, but it gets us something working quickly without having
to replace the whitelabel approval page that Spring OAuth2 would
otherwise pop up for our users when they wanted an access token. To
add an explicit approval step to the token grant, we would need to
provide a UI replacing the whitelabel version (at
`/oauth/confirm_access`).

To finish the Authorization Server, we need to provide security
configuration for its UI. In fact, this simple application does not have much of a user
interface, but we still need to protect the
`/oauth/authorize` endpoint and make sure that the home page
with the "`Login`" buttons is visible. That is why we have the following
method:

====
[source,java]
----
@Override
protected void configure(HttpSecurity http) throws Exception {
  http.antMatcher("/**")                                       // <1>
    .authorizeRequests()
      .antMatchers("/", "/login**", "/webjars/**").permitAll() // <2>
      .anyRequest().authenticated()                            // <3>
    .and().exceptionHandling()
      .authenticationEntryPoint(new LoginUrlAuthenticationEntryPoint("/")) // <4>
    ...
}
----
<1> By default, all requests are protected.
<2> The home page and login endpoints are explicitly excluded.
<3> All other endpoints require an authenticated user.
<4> Unauthenticated users are re-directed to the home page.
====

== How to Get an Access Token

Access tokens are now available from our new authorization server.
The simplest way to get a token up to now is to grab one as the "`acme`"
client. You can see this if you run the app and curl it, as follows:

====
[source,bash]
----
$ curl acme:acmesecret@localhost:8080/oauth/token -d grant_type=client_credentials
{"access_token":"370592fd-b9f8-452d-816a-4fd5c6b4b8a6","token_type":"bearer","expires_in":43199,"scope":"read write"}
----
====

Client credentials tokens are useful in some circumstances (such as
testing that the token endpoint works). However, to take advantage of all
the features of our server, we want to be able to create tokens for
users. To get a token on behalf of a user of our application, we need to be
able to authenticate the user. If you were watching the logs carefully
when the app started, you would have seen a random password being
logged for the default Spring Boot user (per the
https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-security[Spring
Boot User Guide]). You can use this password to get a token on behalf of the user whose ID is `user`, as follows:

====
[source,bash]
----
$ curl acme:acmesecret@localhost:8080/oauth/token -d grant_type=password -d username=user -d password=...
{"access_token":"aa49e025-c4fe-4892-86af-15af2e6b72a2","token_type":"bearer","refresh_token":"97a9f978-7aad-4af7-9329-78ff2ce9962d","expires_in":43199,"scope":"read write"}
----
====

where "..." should be replaced with the actual password. This is
called a "`password grant`", where you exchange a username and password
for an access token.

A password grant is mainly useful for testing but can be
appropriate for a native or mobile application, when you have a local
user database to store and validate the credentials. For most applications (or
any application with "`social`" login, like ours), you need the "`authorization
code`" grant, and that means you need a browser (or a client that
behaves like a browser) to handle redirects and cookies and render
the user interfaces from the external providers.

== Creating a Client Application

A client application for our authorization server that is itself a web
application is easy to create with Spring Boot. The following example shows such an application:

.ClientApplication.java
====
[source,java]
----
@EnableAutoConfiguration
@Configuration
@EnableOAuth2Sso
@RestController
public class ClientApplication {

  @RequestMapping("/")
  public String home(Principal user) {
    return "Hello " + user.getName();
  }

  public static void main(String[] args) {
    new SpringApplicationBuilder(ClientApplication.class)
        .properties("spring.config.name=client").run(args);
  }

}
----
====

NOTE: The `ClientApplication` class MUST NOT be created in the same
package as (or a sub-package of) the `SocialApplication` class. Otherwise,
Spring loads some `ClientApplication` autoconfigurations while
starting the `SocialApplication` server, resulting in startup errors.

The ingredients of the client are a home page (which prints the user's
name) and an explicit name for a configuration file (by setting
`spring.config.name=client`). When we run this application, it looks for a
configuration file that we provide, as follows:

.client.yml
====
[source,yaml]
----
server:
  port: 9999
  context-path: /client
security:
  oauth2:
    client:
      client-id: acme
      client-secret: acmesecret
      access-token-uri: http://localhost:8080/oauth/token
      user-authorization-uri: http://localhost:8080/oauth/authorize
    resource:
      user-info-uri: http://localhost:8080/me
----
====

The configuration looks a lot like the values we used in the main application,
but with the "`acme`" client instead of the Facebook or Github clients. The
application runs on port 9999 to avoid conflicts with the main app. It also
refers to a user info endpoint (`/me`) that we have yet to implement.

Note that the `server.context-path` is set explicitly. So, if you run
the application to test it, remember that the home page is
http://localhost:9999/client.  Clicking on that link should take you
to the auth server, and, once you you have authenticated with the social
provider of your choice, you are redirected back to the client
application.

NOTE: If you run both the
client and the auth server on localhost, the context path has to be explicit.
Otherwise, the cookie paths
clash, and the two applications cannot agree on a session identifier.

== Protecting the User Info Endpoint

To use our new authorization server for single sign on, as we
have been using Facebook and Github, it needs to have a `/user`
endpoint that is protected by the access tokens it creates. So far, we
have a `/user` endpoint, and it is secured with cookies that are created when
the user authenticates. To secure it in addition with the access
tokens granted locally, we can re-use the existing endpoint and
make an alias to it on a new path, as follows:

.SocialApplication.java
====
[source,java]
----
@RequestMapping({ "/user", "/me" })
public Map<String, String> user(Principal principal) {
  Map<String, String> map = new LinkedHashMap<>();
  map.put("name", principal.getName());
  return map;
}
----
====

NOTE: We have converted the `Principal` into a `Map` to hide the
parts that we do not want to expose to the browser and to unify
the behavior of the endpoint between the two external authentication
providers. In principle, we could add more detail here, such as a
provider-specific unique identifier for instance or an e-mail address
(if it is available).

We can now protect the `/me` path with the access token by declaring
that our app is a resource server (as well as an authorization
server). We create a new configuration class (as an inner class in the
main application, but it could also be split out into a separate standalone
class), as follows:

.SocialApplication.java
====
[source,java]
----
@Configuration
@EnableResourceServer
protected static class ResourceServerConfiguration
    extends ResourceServerConfigurerAdapter {
  @Override
  public void configure(HttpSecurity http) throws Exception {
    http
      .antMatcher("/me")
      .authorizeRequests().anyRequest().authenticated();
  }
}
----
====

In addition, we need to specify an `@Order` for the main application
security, as follows:

.SocialApplication.java
====
[source,java]
----
@SpringBootApplication
...
@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)
public class SocialApplication extends WebSecurityConfigurerAdapter {
  ...
}
----
====

By default, the `@EnableResourceServer` annotation creates a security filter with
`@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER-1)`. So, by
moving the main application security to
`@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)`, we ensure that the
rule for `/me` takes precedence.

== Testing the OAuth2 Client

To test the new features, you can run both applications and visit
http://localhost:9999/client in your browser. The client application
redirects to the local authorization server, which then gives the user
the usual choice of authenticating with Facebook or Github. Once that
is complete, control returns to the test client, the local access token
is granted, and authentication is complete (you should see a "`Hello`"
message in your browser). If you are already authenticated with Github
or Facebook, you may not even notice the remote authentication.
