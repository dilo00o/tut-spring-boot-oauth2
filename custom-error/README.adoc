[[_custom_error]]
= Adding an Error Page for Unauthenticated Users

In this section, we modify the <<_social_login_logout,logout>> app we
built earlier, switching to Github authentication, and also giving
some feedback to users that cannot authenticate. At the same time, we
take the opportunity to extend the authentication logic to include a
rule that allows users only if they belong to a specific Github
organization. The "`organization`" is a Github domain-specific concept,
but similar rules could be devised for other providers (for example, with
Google, you might want to authenticate only users from a specific
domain).

== Switching to Github

The <<_social_login_logout,logout>> sample uses Facebook as an OAuth2
provider. We can easily switch to Github by changing the local
configuration, as follows:

.application.yml
====
[source,yaml]
----
security:
  oauth2:
    client:
      clientId: bd1c0a783ccdd1c9b9e4
      clientSecret: 1a9030fbca47a5b2c28e92f19050bb77824b5ad1
      accessTokenUri: https://github.com/login/oauth/access_token
      userAuthorizationUri: https://github.com/login/oauth/authorize
      clientAuthenticationScheme: form
    resource:
      userInfoUri: https://api.github.com/user
----
====

== Detecting an Authentication Failure in the Client

On the client, we need to be able to provide some feedback for a user
that could not authenticate. To facilitate this, we add a `<div>` element with an
informative message, as follows:

.index.html
====
[source,html]
----
<div class="container text-danger error" style="display:none">
There was an error (bad credentials).
</div>
----
====

This text is shown only when the `error` element is shown,
so we need the following code to do that:

.index.html
====
[source,javascript]
----
$.ajax({
  url : "/user",
  success : function(data) {
    $(".unauthenticated").hide();
    $("#user").html(data.userAuthentication.details.name);
    $(".authenticated").show();
  },
  error : function(data) {
    $("#user").html('');
    $(".unauthenticated").show();
    $(".authenticated").hide();
    if (location.href.indexOf("error=true")>=0) {
      $(".error").show();
    }
  }
});
----
====

The authentication function checks the browser location when it loads.
If it finds a URL with `error=true` in it, the flag is set.

== Adding an Error Page

To support the flag setting in the client, we need to be able to
capture an authentication error and redirect to the home page
with that flag set in the query parameters. Hence, we need an
endpoint in a regular `@Controller`, as follows:

.SocialApplication.java
====
[source,java]
----
@RequestMapping("/unauthenticated")
public String unauthenticated() {
  return "redirect:/?error=true";
}
----
====

In the sample application, we put this in the main application class, which is
now a `@Controller` (not a `@RestController`) so that it can handle the
redirect. The final thing we need is a mapping from an unauthenticated
response (HTTP 401, which means UNAUTHORIZED) to the `/unauthenticated`
endpoint we just added, as follows:

.ServletCustomizer.java
====
[source,java]
----
@Configuration
public class ServletCustomizer {
  @Bean
  public EmbeddedServletContainerCustomizer customizer() {
    return container -> {
      container.addErrorPages(new ErrorPage(HttpStatus.UNAUTHORIZED, "/unauthenticated"));
    };
  }
}
----
====

(In the sample, this is added as a nested class inside the main
application, for conciseness.)

== Generating a 401 in the Server

A 401 response already comes from Spring Security if the user
cannot or does not want to login with Github, so the app is already
working if you fail to authenticate (for example, by rejecting the token
grant).

To spice things up a bit, we will extend the authentication rule to
reject users that are not in the right organization. It is easy to use
the Github API to find out more about the user, so we just need to
plug that into the right part of the authentication
process. Fortunately, for such a simple use case, Spring Boot has
provided an easy extension point: if we declare a `@Bean` of type
`AuthoritiesExtractor`, it is used to construct the authorities
(typically "`roles`") of an authenticated user. We can use that hook to
assert that the user is in the correct organization and throw an
exception if not, as follows:

.SocialApplication.java
====
[source,java]
----
@Bean
public AuthoritiesExtractor authoritiesExtractor(OAuth2RestOperations template) {
  return map -> {
    String url = (String) map.get("organizations_url");
    @SuppressWarnings("unchecked")
    List<Map<String, Object>> orgs = template.getForObject(url, List.class);
    if (orgs.stream()
        .anyMatch(org -> "spring-projects".equals(org.get("login")))) {
      return AuthorityUtils.commaSeparatedStringToAuthorityList("ROLE_USER");
    }
    throw new BadCredentialsException("Not in Spring Projects origanization");
  };
}
----
====

Note that we have autowired an `OAuth2RestOperations` object into this method,
so we can use that to access the Github API on behalf of the
authenticated user. We do that and loop over the organizations,
looking for one that matches `spring-projects` (this is the
organization that is used to store Spring open-source projects). You
can substitute your own value there if you want to be able to
authenticate successfully and you are not in the Spring Engineering
team. If there is no match, we throw `BadCredentialsException`, and
this is picked up by Spring Security and turned in to a 401 response.

The `OAuth2RestOperations` has to be created as a bean as well (as of
Spring Boot 1.4), but doing so is trivial because its ingredients are all
autowirable by virtue of having used `@EnableOAuth2Sso`.
The following listing shows how to do so:

====
[source,java,indent=0]
----
@Bean
public OAuth2RestTemplate oauth2RestTemplate(OAuth2ProtectedResourceDetails resource, OAuth2ClientContext context) {
	return new OAuth2RestTemplate(resource, context);
}
----
====

TIP: The preceding code can be generalized to other
authentication rules, some applicable to Github and some to other
OAuth2 providers. All you need is the `OAuth2RestOperations` and some
knowledge of the provider's API.
